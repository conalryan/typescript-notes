[Reactor pattern](https://en.wikipedia.org/wiki/Reactor_pattern)
================================================================================

An event handling pattern for handling service requests delivered concurrently to a service handler by one or more inputs. The service handler then demultiplexes the incoming requests and dispatches them synchronously to the associated request handlers

All reactor systems are single-threaded by definition, but can exist in a multithreaded environment.

### Structure
Resources
Any resource that can provide input to or consume output from the system.

Synchronous Event Demultiplexer
Uses an event loop to block on all resources. The demultiplexer sends the resource to the dispatcher when it is possible to start a synchronous operation on a resource without blocking (Example: a synchronous call to read() will block if there is no data to read. The demultiplexer uses select() on the resource, which blocks until the resource is available for reading. In this case, a synchronous call to read() won't block, and the demultiplexer can send the resource to the dispatcher.)

Dispatcher
Handles registering and unregistering of request handlers. Dispatches resources from the demultiplexer to the associated request handler.
Request Handler
An application defined request handler and its associated resource.

Benefits
The reactor pattern completely separates application-specific code from the reactor implementation, which means that application components can be divided into modular, reusable parts.

Limitations
The reactor pattern can be more difficult to debug[2] than a procedural pattern due to the inverted flow of control. Also, by only calling request handlers synchronously, the reactor pattern limits maximum concurrency, especially on symmetric multiprocessing hardware. The scalability of the reactor pattern is limited not only by calling request handlers synchronously, but also by the demultiplexer



The Subscribe method is how you connect an observer to an Observable. Your observer implements some subset of the following methods:

onNext
An Observable calls this method whenever the Observable emits an item. This method takes as a parameter the item emitted by the Observable.
onError
An Observable calls this method to indicate that it has failed to generate the expected data or has encountered some other error. It will not make further calls to onNext or onCompleted. The onError method takes as its parameter an indication of what caused the error.
onCompleted
An Observable calls this method after it has called onNext for the final time, if it has not encountered any errors.

### Hot and Cold
A “hot” Observable may begin emitting items as soon as it is created, and so any observer who later subscribes to that Observable may start observing the sequence somewhere in the middle.

A “cold” Observable, on the other hand, waits until an observer subscribes to it before it begins to emit items, and so such an observer is guaranteed to see the whole sequence from the beginning.

a “Connectable” Observable. Such an Observable does not begin emitting items until its Connect method is called, whether or not any observers have subscribed to it.


[Operators](http://reactivex.io/documentation/operators.html)
--------------------------------------------------------------------------------

### Composition via Operators
operators that allow you to transform, combine, manipulate, and work with the sequences of items emitted by Observables.

Creating Observables
`Create, Defer, Empty/Never/Throw, From, Interval, Just, Range, Repeat, Start, and Timer`
Transforming Observable Items
`Buffer, FlatMap, GroupBy, Map, Scan, and Windowi`
Filtering Observables
`Debounce, Distinct, ElementAt, Filter, First, IgnoreElements, Last, Sample, Skip, SkipLast, Take, and TakeLast`
Combining Observables
`And/Then/When, CombineLatest, Join, Merge, StartWith, Switch, and Zip`
Error Handling Operators
`Catch and Retry`
Utility Operators
`Delay, Do, Materialize/Dematerialize, ObserveOn, Serialize, Subscribe, SubscribeOn, TimeInterval, Timeout, Timestamp, and Usingi`
Conditional and Boolean Operators
`All, Amb, Contains, DefaultIfEmpty, SequenceEqual, SkipUntil, SkipWhile, TakeUntil, and TakeWhilei`
Mathematical and Aggregate Operators
`Average, Concat, Count, Max, Min, Reduce, and Sumi`
Converting Observables
`Toi`
Connectable Observable Operators
`Connect, Publish, RefCount, and Replayi`
Backpressure Operators
a variety of operators that enforce particular flow-control policies

### Chaining Operators
Similar to Builder pattern however, with Observable operators order matters.
A chain of Observable operators do not operate independently on the original Observable that originates the chain, but they operate in turn, each one operating on the Observable generated by the operator immediately previous in the chain

### I want to create an Observable by combining other Observables
...and emitting all of the items from all of the Observables in whatever order they are received: `Merge`
...and emitting all of the items from all of the Observables, one Observable at a time: `Concat`
...by combining the items from two or more Observables sequentially to come up with new items to emit
  ...whenever each of the Observables has emitted a new item: `Zip`
  ...whenever any of the Observables has emitted a new item: `CombineLatest`
  ...whenever an item is emitted by one Observable in a window defined by an item emitted by another: `Join`
    ...by means of Pattern and Plan intermediaries: `And/Then/When`
  ...and emitting the items from only the most-recently emitted of those Observables: `Switch`

[Single](http://reactivex.io/documentation/single.html)
--------------------------------------------------------------------------------
RxJava (and its derivatives like RxGroovy & RxScala) has developed an Observable variant called “Single.”

A Single is something like an Observable, but instead of emitting a series of values — anywhere from none at all to an infinite number — it always either emits one value or an error notification.

For this reason, instead of subscribing to a Single with the three methods you use to respond to notifications from an Observable (onNext, onError, and onCompleted), you only use two methods to subscribe:

onSuccess
a Single passes this method the sole item that the Single emits
onError
a Single passes this method the Throwable that caused the Single to be unable to emit an item
A Single will call only one of these methods, and will only call it once. Uon calling either method, the Single terminates and the subscription to it ends.p

[Subject](http://reactivex.io/documentation/subject.html)
--------------------------------------------------------------------------------

A Subject is a sort of bridge or proxy that is available in some implementations of ReactiveX that acts both as an observer and as an Observable. Because it is an observer, it can subscribe to one or more Observables, and because it is an Observable, it can pass through the items it observes by reemitting them, and it can also emit new items.

Because a Subject subscribes to an Observable, it will trigger that Observable to begin emitting items (if that Observable is “cold” — that is, if it waits for a subscription before it begins to emit items). This can have the effect of making the resulting Subject a “hot” Observable variant of the original “cold” Observable.

### AsyncSubject
An AsyncSubject emits the last value (and only the last value) emitted by the source Observable, and only after that source Observable completes. (If the source Observable does not emit any values, the AsyncSubject also completes without emitting any values.)

### BehaviorSubject
When an observer subscribes to a BehaviorSubject, it begins by emitting the item most recently emitted by the source Observable (or a seed/default value if none has yet been emitted) and then continues to emit any other items emitted later by the source Observable(s).

### PublishSubject
PublishSubject emits to an observer only those items that are emitted by the source Observable(s) subsequent to the time of the subscription.

Note that a PublishSubject may begin emitting items immediately upon creation (unless you have taken steps to prevent this), and so there is a risk that one or more items may be lost between the time the Subject is created and the observer subscribes to it. If you need to guarantee delivery of all items from the source Observable, you’ll need either to form that Observable with Create so that you can manually reintroduce “cold” Observable behavior (checking to see that all observers have subscribed before beginning to emit items), or switch to using a ReplaySubject instead.

### ReplaySubject
ReplaySubject emits to any observer all of the items that were emitted by the source Observable(s), regardless of when the observer subscribes.

If you use a ReplaySubject as an observer, take care not to call its onNext method (or its other on methods) from multiple threads, as this could lead to coincident (non-sequential) calls, which violates the Observable contract and creates an ambiguity in the resulting Subject as to which item or notification should be replayed first.

[Scheduler](http://reactivex.io/documentation/scheduler.html)
--------------------------------------------------------------------------------

If you want to introduce multithreading into your cascade of Observable operators, you can do so by instructing those operators (or particular Observables) to operate on particular Schedulers.

Some ReactiveX Observable operators have variants that take a Scheduler as a parameter. These instruct the operator to do some or all of its work on a particular Scheduler.

By default, an Observable and the chain of operators that you apply to it will do its work, and will notify its observers, on the same thread on which its Subscribe method is called. The SubscribeOn operator changes this behavior by specifying a different Scheduler on which the Observable should operate. The ObserveOn operator specifies a different Scheduler that the Observable will use to send notifications to its observers.

As shown in this illustration, the SubscribeOn operator designates which thread the Observable will begin operating on, no matter at what point in the chain of operators that operator is called. ObserveOn, on the other hand, affects the thread that the Observable will use below where that operator appears. For this reason, you may call ObserveOn multiple times at various points during the chain of Observable operators in order to change on which threads certain of those operators operate.


